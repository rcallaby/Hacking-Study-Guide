# Kernel Exploits

The **Linux Kernel** is the core component of the Linux operating system. It acts as an interface between hardware and user applications, managing system resources like CPU, memory, I/O devices, and security permissions. It is **monolithic**, meaning it runs as a single process in kernel mode but is modular, allowing the addition and removal of features dynamically.

---

## **1. Kernel Architecture Overview**  

At a high level, the Linux Kernel can be divided into several key subsystems:

```
+-----------------------------------------+
|        User Space (Applications)        |
+-----------------------------------------+
|   System Call Interface (syscalls)      |
+-----------------------------------------+
|   Kernel Space                          |
|   +---------------------------------+   |
|   | Process Management (Scheduler)  |   |
|   +---------------------------------+   |
|   | Memory Management (Paging, MMU) |   |
|   +---------------------------------+   |
|   | Virtual File System (VFS)       |   |
|   +---------------------------------+   |
|   | Device Drivers                  |   |
|   +---------------------------------+   |
|   | Network Stack                   |   |
|   +---------------------------------+   |
|   | Security & Access Control        |   |
+-----------------------------------------+
|        Hardware (CPU, Memory, I/O)      |
+-----------------------------------------+
```

Each of these subsystems plays a crucial role:

### **2. Key Components of the Linux Kernel**
#### **2.1 System Call Interface (SCI)**
- Provides the bridge between user-space applications and kernel services.
- Applications make system calls (e.g., `read()`, `write()`, `open()`, `execve()`) to interact with the OS.
- System calls are managed through software interrupts (e.g., `int 0x80` on x86 or `syscall` instruction on x86-64).

#### **2.2 Process Management (Scheduler)**
- The **scheduler** ensures fair CPU time distribution among processes.
- Uses various scheduling algorithms like:
  - **Completely Fair Scheduler (CFS)** for desktop/server workloads.
  - **Real-Time Scheduling** for latency-sensitive tasks.
- Supports multitasking, context switching, and inter-process communication (IPC).

#### **2.3 Memory Management**
- Manages RAM allocation, virtual memory, and paging.
- Uses a **Memory Management Unit (MMU)** to map virtual addresses to physical memory.
- Supports **demand paging** (loads only required memory pages) and **swap space** (uses disk when RAM is full).

#### **2.4 Virtual File System (VFS)**
- Provides a uniform interface for interacting with different file systems (ext4, XFS, Btrfs, etc.).
- Abstracts low-level file system operations so user applications can access files seamlessly.
- Supports mounting multiple file systems under a single directory tree.

#### **2.5 Device Drivers**
- Kernel modules that allow communication between the OS and hardware.
- Includes drivers for storage devices, network cards, GPUs, sound cards, and peripherals.
- Implemented as **Loadable Kernel Modules (LKMs)**, which can be dynamically loaded or unloaded.

#### **2.6 Networking Stack**
- Implements protocols like TCP/IP, UDP, and ICMP.
- Manages network sockets, packet routing, and firewall rules (via `iptables`/`nftables`).
- Supports network drivers and interfaces (Ethernet, Wi-Fi, loopback).

#### **2.7 Security & Access Control**
- Implements **Discretionary Access Control (DAC)** (file permissions).
- Supports **Mandatory Access Control (MAC)** via **SELinux** and **AppArmor**.
- Includes features like:
  - **User namespaces** (for container security).
  - **Address Space Layout Randomization (ASLR)** to prevent buffer overflow exploits.

---

## **3. Kernel vs. User Space**
- **User space:** Where applications run (e.g., `bash`, `vim`, `python`).
- **Kernel space:** Handles privileged operations (e.g., memory management, scheduling).
- Transition between these spaces happens via **system calls**.

### **Diagram: Kernel vs. User Space**
```
+---------------------+           +-----------------+
| User-Space Program |  ---->     |   Kernel Space  |
|  (e.g., ls, cat)   |  System    |  (Manages CPU,  |
|                     |  Call     |   Memory, I/O)  |
+---------------------+           +-----------------+
```

---

## **4. Monolithic vs. Microkernel Design**
Linux uses a **monolithic kernel** design, meaning:
- The entire OS runs as a single program in **kernel mode**.
- However, it is **modular**, allowing loadable kernel modules (LKMs) to extend functionality dynamically.

In contrast, **microkernels** (e.g., Minix) run most services in user space for better security and isolation but at a performance cost.

### **Diagram: Monolithic vs. Microkernel**
```
Monolithic Kernel (Linux)         Microkernel (Minix, QNX)
-------------------------         ------------------------
| Kernel (All Services)  |        | Kernel (Minimal Core) |
| Scheduler, Memory,     |        | Message Passing       |
| Drivers, File System   |        | (User-Space Services) |
| Network Stack          |        | File System, Drivers  |
-------------------------         ------------------------
```

---

## **5. Kernel Development & Customization**
- The Linux Kernel is **open-source** (licensed under GPLv2).
- Developers can customize or compile their own kernel (`make menuconfig`).
- New versions are released by Linus Torvalds and maintained at **kernel.org**.

### **Common Kernel Customizations**
- **Custom compiling:** `make && make modules_install && make install`
- **Adding/removing features:** `modprobe` to load/unload modules.
- **Tuning performance:** Using `sysctl` to adjust kernel parameters.

---

## **6. Kernel Boot Process**
1. **BIOS/UEFI loads the bootloader** (e.g., GRUB, systemd-boot).
2. **Bootloader loads the Linux kernel** into memory.
3. **Kernel initializes hardware & mounts the root filesystem.**
4. **Init system starts user-space processes** (`systemd`, `SysVinit`, or `OpenRC`).
5. The user gets a **login prompt or GUI desktop**.

### **Diagram: Linux Boot Sequence**
```
1. BIOS/UEFI
   ↓
2. Bootloader (GRUB, LILO)
   ↓
3. Linux Kernel (Loads device drivers)
   ↓
4. Init System (systemd, init)
   ↓
5. User Space (Login shell, Desktop)
```

---

## **7. Conclusion**
The Linux Kernel is the backbone of the operating system, handling low-level operations while providing a stable interface for applications. Its **monolithic yet modular** design ensures performance, security, and flexibility, making it the foundation of many modern systems, from Android smartphones to supercomputers.

Be sure to reference the various Linux Kernel exploits on GitHub such as those found on lucyos/kernel-exploits

When you enemurate a Linux box you can tell which Kernel it is running by checking uname such as:

```
uname -a
```
Further, you can enumerate other parts of the system by using the following commands:

```
lspci
```
you can enumerate any usb drives that may be connect to the system through the following:

```
lsusb
```
further, you can enumerate Kernel Modules with the following:
```
lsmod
```
As well, you can enumerate the Linux Kernel configuration by viewing the Kernel configuration
```
cat /proc/config.gz
```
As well you can using the following:
```
sudo apt-get install libncurses-dev
cd /usr/src/linux
make menuconfig
```

You can check the exploitdb for the various exploits based upon the kernel you are running such as the "dirty cow" exploit which runs on various versions of Kernels

Kernel exploits are very easy to identify through a Google method or through automated tools.

## List of tools to detect and exploit Kernel Exploits
* [kysmHunter](https://github.com/jonoberheide/ksymhunter) - This is a tool that can hunt down kernel exploits
* [kstructhunter](https://github.com/jonoberheide/kstructhunter) - Just check it out
* [AutoLocalPrivlegeEscalation](https://github.com/ngalongc/AutoLocalPrivilegeEscalation) - A script to automatically exploit the linux kernel

## Good Tutorials for Learning Kernel Exploits
* [Step by Step Linux Kernel Exploitation](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html) - A four part series on how to exploit the Linux Kernel Step by Step
* [Learning Linux Kernel Exploitation - Laying the groundwork](https://0x434b.dev/dabbling-with-linux-kernel-exploitation-ctf-challenges-to-learn-the-ropes/) - A good guide on how Linux Kernel Exploitation works
* [The Linux Privilege Escalation Using Kernel Exploit](https://ethicalhackingguru.com/the-linux-privilege-escalation-using-kernel-exploit-walkthrough/) - A good overview of Linux Privilege Escalation
* [How to conduct Linux Privilege Escalations](https://www.techtarget.com/searchsecurity/feature/How-to-conduct-Linux-privilege-escalations) - A good tutorial by TechTarget